/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as moment from "moment";


/**
 * @class
 * Initializes a new instance of the AndroidBranchConfigurationProperties class.
 * @constructor
 * Build configuration for Android projects
 *
 * @member {string} [gradleWrapperPath] Path to the Gradle wrapper script
 * @member {string} module The Gradle module to build
 * @member {string} variant The Android build variant to build
 * @member {boolean} [runTests] Whether to run unit tests during the build
 * (default). Default value: true .
 * @member {boolean} [runLint] Whether to run lint checks during the build
 * (default). Default value: true .
 */
export interface AndroidBranchConfigurationProperties {
  gradleWrapperPath?: string;
  module: string;
  variant: string;
  runTests?: boolean;
  runLint?: boolean;
}

/**
 * @class
 * Initializes a new instance of the AndroidModule class.
 * @constructor
 * @member {string} name Name of the Android module
 * @member {array} [productFlavors] The product flavors of the Android module
 * @member {array} [buildVariants] The detected build variants of the Android
 * module (matrix of product flavor + build type (debug|release))
 * @member {array} [buildTypes] The detected build types fo the Android module
 * @member {boolean} [isRoot] Whether the module is at the root level of the
 * project
 */
export interface AndroidModule {
  name: string;
  productFlavors?: string[];
  buildVariants?: string[];
  buildTypes?: string[];
  isRoot?: boolean;
}

/**
 * @class
 * Initializes a new instance of the AndroidProject class.
 * @constructor
 * @member {array} androidModules Android Gradle modules
 * @member {string} [gradleWrapperPath] The path of the Gradle wrapper
 */
export interface AndroidProject {
  androidModules: AndroidModule[];
  gradleWrapperPath?: string;
}

/**
 * @class
 * Initializes a new instance of the Commit class.
 * @constructor
 * @member {string} [sha] The commit SHA
 * @member {string} [url] The URL to the commit
 */
export interface Commit {
  sha?: string;
  url?: string;
}

/**
 * @class
 * Initializes a new instance of the Branch class.
 * @constructor
 * @member {string} name The branch name
 * @member {object} commit
 * @member {string} [commit.sha] The commit SHA
 * @member {string} [commit.url] The URL to the commit
 */
export interface Branch {
  name: string;
  commit: Commit;
}

/**
 * @class
 * Initializes a new instance of the XcodeBranchConfigurationProperties class.
 * @constructor
 * Build configuration when Xcode is part of the build steps
 *
 * @member {string} projectOrWorkspacePath Xcode project/workspace path
 * @member {string} [podfilePath] Path to CococaPods file, if present
 * @member {string} [cartfilePath] Path to Carthage file, if present
 * @member {string} [provisioningProfileEncoded]
 * @member {string} [certificateEncoded]
 * @member {string} [provisioningProfileFileId]
 * @member {string} [certificateFileId]
 * @member {string} [provisioningProfileUploadId]
 * @member {string} [certificateUploadId]
 * @member {string} [certificatePassword]
 * @member {string} scheme
 * @member {string} xcodeVersion
 * @member {string} [provisioningProfileFilename]
 * @member {string} [certificateFilename]
 * @member {string} [teamId]
 * @member {boolean} [automaticSigning]
 * @member {string} [xcodeProjectSha] The selected pbxproject hash to the
 * repositroy
 * @member {string} [archiveConfiguration] The build configuration of the
 * target to archive
 * @member {string} [targetToArchive] The target id of the selected scheme to
 * archive
 */
export interface XcodeBranchConfigurationProperties {
  projectOrWorkspacePath: string;
  podfilePath?: string;
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme: string;
  xcodeVersion: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  xcodeProjectSha?: string;
  archiveConfiguration?: string;
  targetToArchive?: string;
}

/**
 * @class
 * Initializes a new instance of the JavaScriptBranchConfigurationProperties class.
 * @constructor
 * Build configuration when React Native, or other JavaScript tech, is part of
 * the build steps
 *
 * @member {string} packageJsonPath Path to package.json file for the main
 * project, e.g. "package.json" or "myapp/package.json"
 * @member {boolean} [runTests] Whether to run Jest unit tests, via npm test,
 * during the build. Default value: true .
 * @member {string} [reactNativeVersion] Version of React Native from
 * package.json files
 */
export interface JavaScriptBranchConfigurationProperties {
  packageJsonPath: string;
  runTests?: boolean;
  reactNativeVersion?: string;
}

/**
 * @class
 * Initializes a new instance of the XamarinBranchConfigurationProperties class.
 * @constructor
 * Build configuration for Xamarin projects
 *
 * @member {string} slnPath
 * @member {string} isSimBuild
 * @member {string} args
 * @member {string} configuration
 * @member {string} p12File
 * @member {string} p12Pwd
 * @member {string} provProfile
 * @member {string} [monoVersion]
 * @member {string} [sdkBundle]
 */
export interface XamarinBranchConfigurationProperties {
  slnPath: string;
  isSimBuild: string;
  args: string;
  configuration: string;
  p12File: string;
  p12Pwd: string;
  provProfile: string;
  monoVersion?: string;
  sdkBundle?: string;
}

/**
 * @class
 * Initializes a new instance of the BranchConfigurationToolsets class.
 * @constructor
 * The branch build configuration for each toolset
 *
 * @member {object} [xcode]
 * @member {string} [xcode.projectOrWorkspacePath] Xcode project/workspace path
 * @member {string} [xcode.podfilePath] Path to CococaPods file, if present
 * @member {string} [xcode.cartfilePath] Path to Carthage file, if present
 * @member {string} [xcode.provisioningProfileEncoded]
 * @member {string} [xcode.certificateEncoded]
 * @member {string} [xcode.provisioningProfileFileId]
 * @member {string} [xcode.certificateFileId]
 * @member {string} [xcode.provisioningProfileUploadId]
 * @member {string} [xcode.certificateUploadId]
 * @member {string} [xcode.certificatePassword]
 * @member {string} [xcode.scheme]
 * @member {string} [xcode.xcodeVersion]
 * @member {string} [xcode.provisioningProfileFilename]
 * @member {string} [xcode.certificateFilename]
 * @member {string} [xcode.teamId]
 * @member {boolean} [xcode.automaticSigning]
 * @member {string} [xcode.xcodeProjectSha] The selected pbxproject hash to the
 * repositroy
 * @member {string} [xcode.archiveConfiguration] The build configuration of the
 * target to archive
 * @member {string} [xcode.targetToArchive] The target id of the selected
 * scheme to archive
 * @member {object} [javascript]
 * @member {string} [javascript.packageJsonPath] Path to package.json file for
 * the main project, e.g. "package.json" or "myapp/package.json"
 * @member {boolean} [javascript.runTests] Whether to run Jest unit tests, via
 * npm test, during the build
 * @member {string} [javascript.reactNativeVersion] Version of React Native
 * from package.json files
 * @member {object} [xamarin]
 * @member {string} [xamarin.slnPath]
 * @member {string} [xamarin.isSimBuild]
 * @member {string} [xamarin.args]
 * @member {string} [xamarin.configuration]
 * @member {string} [xamarin.p12File]
 * @member {string} [xamarin.p12Pwd]
 * @member {string} [xamarin.provProfile]
 * @member {string} [xamarin.monoVersion]
 * @member {string} [xamarin.sdkBundle]
 * @member {object} [android]
 * @member {string} [android.gradleWrapperPath] Path to the Gradle wrapper
 * script
 * @member {string} [android.module] The Gradle module to build
 * @member {string} [android.variant] The Android build variant to build
 * @member {boolean} [android.runTests] Whether to run unit tests during the
 * build (default)
 * @member {boolean} [android.runLint] Whether to run lint checks during the
 * build (default)
 */
export interface BranchConfigurationToolsets {
  xcode?: XcodeBranchConfigurationProperties;
  javascript?: JavaScriptBranchConfigurationProperties;
  xamarin?: XamarinBranchConfigurationProperties;
  android?: AndroidBranchConfigurationProperties;
}

/**
 * @class
 * Initializes a new instance of the BranchConfigurationArtifactVersioning class.
 * @constructor
 * The versioning configuration for artifacts built for this branch
 *
 * @member {string} [buildNumberFormat] Possible values include: 'buildId',
 * 'timestamp'
 */
export interface BranchConfigurationArtifactVersioning {
  buildNumberFormat?: string;
}

/**
 * @class
 * Initializes a new instance of the BranchConfiguration class.
 * @constructor
 * The branch build configuration
 *
 * @member {number} id
 * @member {string} [trigger] Possible values include: 'continous',
 * 'continuous', 'manual'
 * @member {boolean} [testsEnabled]
 * @member {boolean} [badgeIsEnabled]
 * @member {boolean} [signed]
 * @member {object} [toolsets]
 * @member {object} [toolsets.xcode]
 * @member {string} [toolsets.xcode.projectOrWorkspacePath] Xcode
 * project/workspace path
 * @member {string} [toolsets.xcode.podfilePath] Path to CococaPods file, if
 * present
 * @member {string} [toolsets.xcode.cartfilePath] Path to Carthage file, if
 * present
 * @member {string} [toolsets.xcode.provisioningProfileEncoded]
 * @member {string} [toolsets.xcode.certificateEncoded]
 * @member {string} [toolsets.xcode.provisioningProfileFileId]
 * @member {string} [toolsets.xcode.certificateFileId]
 * @member {string} [toolsets.xcode.provisioningProfileUploadId]
 * @member {string} [toolsets.xcode.certificateUploadId]
 * @member {string} [toolsets.xcode.certificatePassword]
 * @member {string} [toolsets.xcode.scheme]
 * @member {string} [toolsets.xcode.xcodeVersion]
 * @member {string} [toolsets.xcode.provisioningProfileFilename]
 * @member {string} [toolsets.xcode.certificateFilename]
 * @member {string} [toolsets.xcode.teamId]
 * @member {boolean} [toolsets.xcode.automaticSigning]
 * @member {string} [toolsets.xcode.xcodeProjectSha] The selected pbxproject
 * hash to the repositroy
 * @member {string} [toolsets.xcode.archiveConfiguration] The build
 * configuration of the target to archive
 * @member {string} [toolsets.xcode.targetToArchive] The target id of the
 * selected scheme to archive
 * @member {object} [toolsets.javascript]
 * @member {string} [toolsets.javascript.packageJsonPath] Path to package.json
 * file for the main project, e.g. "package.json" or "myapp/package.json"
 * @member {boolean} [toolsets.javascript.runTests] Whether to run Jest unit
 * tests, via npm test, during the build
 * @member {string} [toolsets.javascript.reactNativeVersion] Version of React
 * Native from package.json files
 * @member {object} [toolsets.xamarin]
 * @member {string} [toolsets.xamarin.slnPath]
 * @member {string} [toolsets.xamarin.isSimBuild]
 * @member {string} [toolsets.xamarin.args]
 * @member {string} [toolsets.xamarin.configuration]
 * @member {string} [toolsets.xamarin.p12File]
 * @member {string} [toolsets.xamarin.p12Pwd]
 * @member {string} [toolsets.xamarin.provProfile]
 * @member {string} [toolsets.xamarin.monoVersion]
 * @member {string} [toolsets.xamarin.sdkBundle]
 * @member {object} [toolsets.android]
 * @member {string} [toolsets.android.gradleWrapperPath] Path to the Gradle
 * wrapper script
 * @member {string} [toolsets.android.module] The Gradle module to build
 * @member {string} [toolsets.android.variant] The Android build variant to
 * build
 * @member {boolean} [toolsets.android.runTests] Whether to run unit tests
 * during the build (default)
 * @member {boolean} [toolsets.android.runLint] Whether to run lint checks
 * during the build (default)
 * @member {object} [artifactVersioning]
 * @member {string} [artifactVersioning.buildNumberFormat] Possible values
 * include: 'buildId', 'timestamp'
 */
export interface BranchConfiguration {
  id: number;
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  toolsets?: BranchConfigurationToolsets;
  artifactVersioning?: BranchConfigurationArtifactVersioning;
}

/**
 * @class
 * Initializes a new instance of the BranchProperties class.
 * @constructor
 * The branch build core properties
 *
 * @member {object} [branch]
 * @member {string} [branch.name] The branch name
 * @member {object} [branch.commit]
 * @member {string} [branch.commit.sha] The commit SHA
 * @member {string} [branch.commit.url] The URL to the commit
 * @member {boolean} [enabled]
 */
export interface BranchProperties {
  branch?: Branch;
  enabled?: boolean;
}

/**
 * @class
 * Initializes a new instance of the Build class.
 * @constructor
 * @member {number} id The build ID
 * @member {string} buildNumber The build number
 * @member {string} queueTime The time the build was queued
 * @member {string} [startTime] The time the build was started
 * @member {string} [finishTime] The time the build was finished
 * @member {string} [lastChangedDate] The time the build status was last
 * changed
 * @member {string} status The build status
 * @member {string} result The build result
 * @member {string} sourceBranch The source branch name
 * @member {string} sourceVersion The source SHA
 */
export interface Build {
  id: number;
  buildNumber: string;
  queueTime: string;
  startTime?: string;
  finishTime?: string;
  lastChangedDate?: string;
  status: string;
  result: string;
  sourceBranch: string;
  sourceVersion: string;
}

/**
 * @class
 * Initializes a new instance of the BranchStatus class.
 * @constructor
 * The branch build status
 *
 * @member {boolean} configured
 * @member {object} [lastBuild]
 * @member {number} [lastBuild.id] The build ID
 * @member {string} [lastBuild.buildNumber] The build number
 * @member {string} [lastBuild.queueTime] The time the build was queued
 * @member {string} [lastBuild.startTime] The time the build was started
 * @member {string} [lastBuild.finishTime] The time the build was finished
 * @member {string} [lastBuild.lastChangedDate] The time the build status was
 * last changed
 * @member {string} [lastBuild.status] The build status
 * @member {string} [lastBuild.result] The build result
 * @member {string} [lastBuild.sourceBranch] The source branch name
 * @member {string} [lastBuild.sourceVersion] The source SHA
 */
export interface BranchStatus {
  configured: boolean;
  lastBuild?: Build;
}

/**
 * @class
 * Initializes a new instance of the BuildLog class.
 * @constructor
 * @member {array} [value]
 */
export interface BuildLog {
  value?: string[];
}

/**
 * @class
 * Initializes a new instance of the BuildParams class.
 * @constructor
 * @member {string} [sourceVersion] Version to build
 * @member {boolean} [debug] Run build in debug mode
 */
export interface BuildParams {
  sourceVersion?: string;
  debug?: boolean;
}

/**
 * @class
 * Initializes a new instance of the BuildPatch class.
 * @constructor
 * @member {string} [status] The build status; used to cancel builds. Possible
 * values include: 'cancelling'
 */
export interface BuildPatch {
  status?: string;
}

/**
 * @class
 * Initializes a new instance of the ToolsetProject class.
 * @constructor
 * Abstract platform project
 *
 * @member {string} [name]
 * @member {string} [path]
 */
export interface ToolsetProject {
  name?: string;
  path?: string;
}

/**
 * @class
 * Initializes a new instance of the BuildServiceStatus class.
 * @constructor
 * @member {string} [status]
 * @member {string} [service]
 * @member {string} [message]
 * @member {string} [url]
 * @member {number} [validUntil]
 * @member {string} [os]
 */
export interface BuildServiceStatus {
  status?: string;
  service?: string;
  message?: string;
  url?: string;
  validUntil?: number;
  os?: string;
}

/**
 * @class
 * Initializes a new instance of the CommitDetailsCommitAuthor class.
 * @constructor
 * @member {string} [date] Date and time of the commit
 * @member {string} [name] Author name
 * @member {string} [email] Author's email
 */
export interface CommitDetailsCommitAuthor {
  date?: string;
  name?: string;
  email?: string;
}

/**
 * @class
 * Initializes a new instance of the CommitDetailsCommit class.
 * @constructor
 * @member {string} [message] Commit message
 * @member {object} [author]
 * @member {string} [author.date] Date and time of the commit
 * @member {string} [author.name] Author name
 * @member {string} [author.email] Author's email
 */
export interface CommitDetailsCommit {
  message?: string;
  author?: CommitDetailsCommitAuthor;
}

/**
 * @class
 * Initializes a new instance of the CommitDetails class.
 * @constructor
 * @member {object} [commit]
 * @member {string} [commit.message] Commit message
 * @member {object} [commit.author]
 * @member {string} [commit.author.date] Date and time of the commit
 * @member {string} [commit.author.name] Author name
 * @member {string} [commit.author.email] Author's email
 */
export interface CommitDetails extends Commit {
  commit?: CommitDetailsCommit;
}

/**
 * @class
 * Initializes a new instance of the DistributionRequest class.
 * @constructor
 * @member {string} distributionGroupId The distribution group ID
 * @member {string} [releaseNotes] The release notes
 */
export interface DistributionRequest {
  distributionGroupId: string;
  releaseNotes?: string;
}

/**
 * @class
 * Initializes a new instance of the DistributionResponse class.
 * @constructor
 * @member {string} [status] Status of the Request
 * @member {string} [uploadId] A unique ID of the upload
 */
export interface DistributionResponse {
  status?: string;
  uploadId?: string;
}

/**
 * @class
 * Initializes a new instance of the DownloadContainer class.
 * @constructor
 * A download reference
 *
 * @member {string} uri Download URI
 */
export interface DownloadContainer {
  uri: string;
}

/**
 * @class
 * Initializes a new instance of the FileAsset class.
 * @constructor
 * @member {string} [id]
 * @member {string} [location]
 * @member {string} [token]
 * @member {string} [uploadDomain]
 * @member {string} [uploadWindowLocation]
 * @member {string} [urlEncodedToken]
 */
export interface FileAsset {
  id?: string;
  location?: string;
  token?: string;
  uploadDomain?: string;
  uploadWindowLocation?: string;
  urlEncodedToken?: string;
}

/**
 * @class
 * Initializes a new instance of the JavaScriptSolution class.
 * @constructor
 * @member {string} packageJsonPath The path to the detected package.json
 * @member {string} [reactNativeVersion] Version of React Native from
 * package.json files
 */
export interface JavaScriptSolution {
  packageJsonPath: string;
  reactNativeVersion?: string;
}

/**
 * @class
 * Initializes a new instance of the JavaScriptToolset class.
 * @constructor
 * @member {array} packageJsonPaths Paths for detected package.json files
 * @member {array} [javascriptSolutions] The React Native solutions detected
 */
export interface JavaScriptToolset {
  packageJsonPaths: string[];
  javascriptSolutions?: JavaScriptSolution[];
}

/**
 * @class
 * Initializes a new instance of the MonoVersion class.
 * @constructor
 * The Mono version
 *
 * @member {string} [name] The version name
 * @member {boolean} [current] If the Mono is latest stable
 */
export interface MonoVersion {
  name?: string;
  current?: boolean;
}

/**
 * @class
 * Initializes a new instance of the RepoConfig class.
 * @constructor
 * @member {string} type Type of repository
 * @member {string} state State of the configuration. Possible values include:
 * 'unauthorized', 'inactive', 'active'
 * @member {string} [repoUrl] URL of the repository
 * @member {string} [id] Repository identifier
 */
export interface RepoConfig {
  type: string;
  state: string;
  repoUrl?: string;
  id?: string;
}

/**
 * @class
 * Initializes a new instance of the RepoInfo class.
 * @constructor
 * @member {string} repoUrl The repository url
 */
export interface RepoInfo {
  repoUrl: string;
}

/**
 * @class
 * Initializes a new instance of the SourceRepository class.
 * @constructor
 * The source repository
 *
 * @member {string} [name] The repository name
 * @member {object} [cloneUrl] URL used to clone the repository
 */
export interface SourceRepository {
  name?: string;
  cloneUrl?: any;
}

/**
 * @class
 * Initializes a new instance of the SuccessResponse class.
 * @constructor
 * @member {string} message
 */
export interface SuccessResponse {
  message: string;
}

/**
 * @class
 * Initializes a new instance of the TestCloudProjectFrameworkProperties class.
 * @constructor
 * @member {array} [configurations]
 */
export interface TestCloudProjectFrameworkProperties {
  configurations?: string[];
}

/**
 * @class
 * Initializes a new instance of the TestCloudProject class.
 * @constructor
 * @member {string} path The path to the TestCloud project
 * @member {string} frameworkType Possible values include: 'Appium',
 * 'Calabash', 'Espresso', 'UITest', 'Generated'
 * @member {object} [frameworkProperties]
 * @member {array} [frameworkProperties.configurations]
 */
export interface TestCloudProject {
  path: string;
  frameworkType: string;
  frameworkProperties?: TestCloudProjectFrameworkProperties;
}

/**
 * @class
 * Initializes a new instance of the TestCloudToolset class.
 * @constructor
 * @member {array} projects The TestCloud projects detected
 */
export interface TestCloudToolset {
  projects: TestCloudProject[];
}

/**
 * @class
 * Initializes a new instance of the XcodeArchiveProject class.
 * @constructor
 * @member {string} archiveTargetId The Id of the target to archive
 * @member {string} projectName The project to archive container name
 * @member {string} [projectPath] Full path of the target project
 */
export interface XcodeArchiveProject {
  archiveTargetId: string;
  projectName: string;
  projectPath?: string;
}

/**
 * @class
 * Initializes a new instance of the XcodeScheme class.
 * @constructor
 * @member {string} name Scheme name
 * @member {boolean} hasTestAction Does scheme have a test action?
 * @member {string} [archiveConfiguration] Build configuration set in Archive
 * action
 * @member {object} [archiveProject]
 * @member {string} [archiveProject.archiveTargetId] The Id of the target to
 * archive
 * @member {string} [archiveProject.projectName] The project to archive
 * container name
 * @member {string} [archiveProject.projectPath] Full path of the target
 * project
 */
export interface XcodeScheme {
  name: string;
  hasTestAction: boolean;
  archiveConfiguration?: string;
  archiveProject?: XcodeArchiveProject;
}

/**
 * @class
 * Initializes a new instance of the XcodeSchemeContainer class.
 * @constructor
 * @member {string} path Path to project
 * @member {array} sharedSchemes Project schemes
 * @member {string} [podfilePath] Path to CocoaPods file, if present
 * @member {object} [cartfilePath] Path to Carthage file, if present
 * @member {string} [xcodeProjectSha] repo object Id of the pbxproject
 * @member {string} [workspaceProjectPaths] Related projects paths for
 * xcworkspace
 */
export interface XcodeSchemeContainer {
  path: string;
  sharedSchemes: XcodeScheme[];
  podfilePath?: string;
  cartfilePath?: any;
  xcodeProjectSha?: string;
  workspaceProjectPaths?: string;
}

/**
 * @class
 * Initializes a new instance of the XcodeToolset class.
 * @constructor
 * @member {array} xcodeSchemeContainers The Xcode scheme containers
 */
export interface XcodeToolset {
  xcodeSchemeContainers: XcodeSchemeContainer[];
}

/**
 * @class
 * Initializes a new instance of the XamarinSolution class.
 * @constructor
 * @member {string} path Path to solution
 * @member {array} configurations Solution configurations
 * @member {string} [defaultConfiguration] Solution default configuration
 */
export interface XamarinSolution {
  path: string;
  configurations: string[];
  defaultConfiguration?: string;
}

/**
 * @class
 * Initializes a new instance of the XamarinToolset class.
 * @constructor
 * @member {array} xamarinSolutions Xamarin solutions for the toolset
 */
export interface XamarinToolset {
  xamarinSolutions: XamarinSolution[];
}

/**
 * @class
 * Initializes a new instance of the UWPSolution class.
 * @constructor
 * @member {string} path The path to the UWP solution
 * @member {array} configurations The possible configurations detected for the
 * UWP solution
 */
export interface UWPSolution {
  path: string;
  configurations: string[];
}

/**
 * @class
 * Initializes a new instance of the UWPToolset class.
 * @constructor
 * @member {array} uwpSolutions The UWP solutions detected
 */
export interface UWPToolset {
  uwpSolutions: UWPSolution[];
}

/**
 * @class
 * Initializes a new instance of the ToolsetProjects class.
 * @constructor
 * A collection of projects for each type of toolset
 *
 * @member {string} [commit] The commit hash of the analyzed commit
 * @member {object} [xcode]
 * @member {array} [xcode.xcodeSchemeContainers] The Xcode scheme containers
 * @member {object} [javascript]
 * @member {array} [javascript.packageJsonPaths] Paths for detected
 * package.json files
 * @member {array} [javascript.javascriptSolutions] The React Native solutions
 * detected
 * @member {object} [xamarin]
 * @member {array} [xamarin.xamarinSolutions] Xamarin solutions for the toolset
 * @member {object} [android]
 * @member {array} [android.androidModules] Android Gradle modules
 * @member {string} [android.gradleWrapperPath] The path of the Gradle wrapper
 * @member {object} [buildscripts]
 * @member {object} [uwp]
 * @member {array} [uwp.uwpSolutions] The UWP solutions detected
 * @member {object} [testcloud]
 * @member {array} [testcloud.projects] The TestCloud projects detected
 */
export interface ToolsetProjects {
  commit?: string;
  xcode?: XcodeToolset;
  javascript?: JavaScriptToolset;
  xamarin?: XamarinToolset;
  android?: AndroidProject;
  buildscripts?: { [propertyName: string]: ToolsetProject };
  uwp?: UWPToolset;
  testcloud?: TestCloudToolset;
}

/**
 * @class
 * Initializes a new instance of the XamarinSDKBundle class.
 * @constructor
 * The Xamarin SDK bundle
 *
 * @member {string} [monoVersion] The Mono version
 * @member {string} [sdkBundle] The Xamarin SDK version
 * @member {boolean} [current] If the SDK is latest stable
 */
export interface XamarinSDKBundle {
  monoVersion?: string;
  sdkBundle?: string;
  current?: boolean;
}

/**
 * @class
 * Initializes a new instance of the XcodeVersion class.
 * @constructor
 * The Xcode version
 *
 * @member {string} [name] The version name
 * @member {boolean} [current] If the Xcode is latest stable
 */
export interface XcodeVersion {
  name?: string;
  current?: boolean;
}
